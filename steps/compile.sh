#!/usr/bin/env bash
set -euo pipefail

: '
compile.sh
----------
What this step does:
  1) Loads build/env.sh (generated by verify) if present
  2) Selects the Embedded Swift toolchain (prefers build/.swiftc_path from verify)
  3) Generates a temporary Arduino sketch (C++ shim + Bridge.cpp + sketch.ino)
  4) Compiles Swift code into an .o (ArduinoSwiftApp.o) using Embedded Swift
  5) Invokes arduino-cli compile to build and link using the selected Arduino core/toolchain
'

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CONFIG="$ROOT_DIR/config.json"
BOARDS="$ROOT_DIR/boards.json"

PRINT_SH="$ROOT_DIR/print.sh"
BUILD="$ROOT_DIR/build"
LOG_FILE="$BUILD/compile.log"
: > "$LOG_FILE"

# ----------------------------- UI (shared) -----------------------------
if [[ -f "$PRINT_SH" ]]; then
  # shellcheck disable=SC1090
  source "$PRINT_SH"
else
  ce_title() { echo; echo "=================================================="; echo "$*"; echo "=================================================="; }
  ce_step() { echo; echo "=============================="; echo "==> STEP: $*"; echo "=============================="; }
  ce_info() { echo "INFO  $*"; }
  ce_ok()   { echo "OK    $*"; }
  ce_warn() { echo "WARN  $*" >&2; }
  ce_err()  { echo "ERR   $*" >&2; }
  ce_die()  { ce_err "$*"; exit 1; }
  run_cmd_tee() { local lf="$1"; shift; "$@" 2>&1 | tee -a "$lf"; return ${PIPESTATUS[0]}; }
  run_cmd_bg_tee() { local lf="$1"; local msg="$2"; shift 2; ce_info "$msg"; "$@" 2>&1 | tee -a "$lf"; return ${PIPESTATUS[0]}; }
fi

need() {
  if command -v "$1" >/dev/null 2>&1; then
    ce_ok "Found $1"
  else
    ce_die "Missing dependency: $1"
  fi
}

need arduino-cli
need python3

# Make sure swiftly shims are visible in scripts (macOS/Linux)
export PATH="$HOME/.swiftly/bin:$PATH"

SKETCH="$BUILD/sketch"
ARD_BUILD="$BUILD/arduino_build"
ARD_CACHE="$BUILD/arduino_cache"

ce_info "Preparing build directories..."
# IMPORTANT: Arduino may reuse previously built core objects inside --build-path.
# When we change flags (like enum size), we want a clean rebuild to avoid mixing attributes.
rm -rf "$ARD_BUILD"
mkdir -p "$BUILD" "$SKETCH" "$ARD_BUILD" "$ARD_CACHE"

# ----------------------------- Load env from verify -----------------------------
ENV_SH="$BUILD/env.sh"
if [[ -f "$ENV_SH" ]]; then
  # shellcheck disable=SC1090
  source "$ENV_SH"
fi

# If verify saved the swiftc path, prefer it.
if [[ -f "$BUILD/.swiftc_path" ]]; then
  SWIFTC="$(cat "$BUILD/.swiftc_path")"
fi

# Allow overriding SWIFTC from the environment if user explicitly sets it.
SWIFTC="${SWIFTC:-swiftc}"

# ----------------------------- Read config/boards -----------------------------
BOARD="$(python3 - <<PY
import json
cfg=json.load(open("$CONFIG","r"))
print(cfg["board"])
PY
)"

FQBN="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"]["fqbn"])
PY
)"

SWIFT_TARGET="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"].get("swift_target","armv7-none-none-eabi"))
PY
)"

CPU="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"].get("cpu","cortex-m3"))
PY
)"

# ----------------------------- Embedded Swift capability check -----------------------------
supports_embedded_swift() {
  local sc="$1"
  [[ -x "$sc" ]] || return 1

  # Reliable check:
  # Ask swiftc for runtime resources for armv7-none-none-eabi and verify embedded stdlib exists.
  local target="armv7-none-none-eabi"
  local resdir
  resdir="$("$sc" -print-target-info -target "$target" 2>/dev/null | awk -F'"' '/runtimeResourcePath/ {print $4; exit}')"

  [[ -n "$resdir" && -d "$resdir" && -d "$resdir/embedded" ]]
}

if ! command -v "$SWIFTC" >/dev/null 2>&1 && [[ ! -x "$SWIFTC" ]]; then
  ce_die "swiftc not found: $SWIFTC
Tip: run ./run.sh verify
Or set SWIFTC explicitly:
  SWIFTC=/Library/Developer/Toolchains/<SNAPSHOT>.xctoolchain/usr/bin/swiftc ./run.sh compile"
fi

# Normalize SWIFTC if it is in PATH
if command -v "$SWIFTC" >/dev/null 2>&1; then
  SWIFTC="$(command -v "$SWIFTC")"
fi

ce_info "swiftc: $SWIFTC"
SWIFT_VER="$($SWIFTC --version 2>/dev/null | tr '\n' ' ')"
ce_info "swiftc --version: $SWIFT_VER"
echo "swiftc --version: $SWIFT_VER" >> "$LOG_FILE"

if ! supports_embedded_swift "$SWIFTC"; then
  ce_err "This swiftc does NOT support Embedded Swift."
  ce_err "Run: ./run.sh verify"
  ce_err "Or set SWIFTC explicitly:"
  ce_err "  SWIFTC=/Library/Developer/Toolchains/<SNAPSHOT>.xctoolchain/usr/bin/swiftc ./run.sh compile"
  exit 1
fi

# ----------------------------- Generate temporary Arduino sketch files -----------------------------
cat > "$SKETCH/sketch.ino" <<'INO'
#include <Arduino.h>
#include "ArduinoSwiftShim.h"
// setup/loop live in Bridge.cpp
INO

cat > "$SKETCH/ArduinoSwiftShim.h" <<'H'
#pragma once
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// ----------------------
// Digital
// ----------------------
void     arduino_pinMode(uint32_t pin, uint32_t mode);
void     arduino_digitalWrite(uint32_t pin, uint32_t value);
uint32_t arduino_digitalRead(uint32_t pin);

// ----------------------
// Timing
// ----------------------
void     arduino_delay_ms(uint32_t ms);
uint32_t arduino_millis(void);

// ----------------------
// Analog
// ----------------------
uint32_t arduino_analogRead(uint32_t pin);
void     arduino_analogReadResolution(uint32_t bits);
uint32_t arduino_analogMaxValue(void);

// ----------------------
// Constants
// ----------------------
uint32_t arduino_builtin_led(void);
uint32_t arduino_mode_output(void);
uint32_t arduino_mode_input(void);
uint32_t arduino_mode_input_pullup(void);
uint32_t arduino_high(void);
uint32_t arduino_low(void);

// ----------------------
// External Interrupts (flag-based)
// ----------------------
uint32_t arduino_irq_mode_low(void);
uint32_t arduino_irq_mode_change(void);
uint32_t arduino_irq_mode_rising(void);
uint32_t arduino_irq_mode_falling(void);
uint32_t arduino_irq_mode_high(void);

// Returns slot id (>=0) on success, -1 on failure
int32_t  arduino_irq_attach(uint32_t pin, uint32_t mode);
// Detach slot (safe to call multiple times)
void     arduino_irq_detach(int32_t slot);
// Returns 1 if fired since last consume, else 0
uint32_t arduino_irq_consume(int32_t slot);

// ----------------------
// Serial (USB/TTL)
// ----------------------
void     arduino_serial_begin(uint32_t baud);
void     arduino_serial_print_cstr(const char* s);
void     arduino_serial_print_i32(int32_t v);
void     arduino_serial_print_u32(uint32_t v);
void     arduino_serial_print_f64(double v);

// Symbol exported by Swift
void arduino_swift_main(void);

#ifdef __cplusplus
}
#endif
H

cat > "$SKETCH/ArduinoSwiftShim.cpp" <<'CPP'
#include <Arduino.h>
#include "ArduinoSwiftShim.h"

static uint32_t gAnalogBits = 10; // Arduino default; can be changed by Swift
static uint32_t analogMaxFromBits(uint32_t bits) {
  if (bits == 0) return 0;
  if (bits >= 31) return 0x7FFFFFFFu;
  return ((uint32_t)1u << bits) - 1u;
}

// --------------------------------------------------
// IRQ slots (flag-based)
// --------------------------------------------------
#ifndef ARDUINO_SWIFT_IRQ_SLOTS
#define ARDUINO_SWIFT_IRQ_SLOTS 8
#endif

struct SwiftIrqSlot {
  uint8_t  used;
  uint8_t  irqNumber;          // attachInterrupt expects interrupt number
  volatile uint8_t fired;      // set in ISR, consumed in main loop
};

static SwiftIrqSlot gSlots[ARDUINO_SWIFT_IRQ_SLOTS];

static void irq0() { gSlots[0].fired = 1; }
static void irq1() { gSlots[1].fired = 1; }
static void irq2() { gSlots[2].fired = 1; }
static void irq3() { gSlots[3].fired = 1; }
static void irq4() { gSlots[4].fired = 1; }
static void irq5() { gSlots[5].fired = 1; }
static void irq6() { gSlots[6].fired = 1; }
static void irq7() { gSlots[7].fired = 1; }

static void (*const gHandlers[ARDUINO_SWIFT_IRQ_SLOTS])() = {
  irq0, irq1, irq2, irq3, irq4, irq5, irq6, irq7
};

extern "C" {

// -------- Digital --------

void arduino_pinMode(uint32_t pin, uint32_t mode) {
  ::pinMode((uint8_t)pin, (uint8_t)mode);
}

void arduino_digitalWrite(uint32_t pin, uint32_t value) {
  ::digitalWrite((uint8_t)pin, (uint8_t)value);
}

uint32_t arduino_digitalRead(uint32_t pin) {
  return (uint32_t)::digitalRead((uint8_t)pin);
}

// -------- Timing --------

void arduino_delay_ms(uint32_t ms) {
  ::delay((unsigned long)ms);
}

uint32_t arduino_millis(void) {
  return (uint32_t)::millis();
}

// -------- Analog --------

uint32_t arduino_analogRead(uint32_t pin) {
  return (uint32_t)::analogRead((uint32_t)pin);
}

void arduino_analogReadResolution(uint32_t bits) {
  gAnalogBits = bits;
  ::analogReadResolution((int)bits);
}

uint32_t arduino_analogMaxValue(void) {
  return analogMaxFromBits(gAnalogBits);
}

// -------- Constants --------

uint32_t arduino_builtin_led(void) {
#ifdef LED_BUILTIN
  return (uint32_t)LED_BUILTIN;
#else
  return 13;
#endif
}

uint32_t arduino_mode_output(void) { return (uint32_t)OUTPUT; }
uint32_t arduino_mode_input(void) { return (uint32_t)INPUT; }
uint32_t arduino_mode_input_pullup(void) { return (uint32_t)INPUT_PULLUP; }

uint32_t arduino_high(void) { return (uint32_t)HIGH; }
uint32_t arduino_low(void) { return (uint32_t)LOW; }

// -------- IRQ modes --------
// Arduino attachInterrupt expects these constants:
uint32_t arduino_irq_mode_low(void)     { return (uint32_t)LOW; }
uint32_t arduino_irq_mode_change(void)  { return (uint32_t)CHANGE; }
uint32_t arduino_irq_mode_rising(void)  { return (uint32_t)RISING; }
uint32_t arduino_irq_mode_falling(void) { return (uint32_t)FALLING; }
uint32_t arduino_irq_mode_high(void)    { return (uint32_t)HIGH; }

// Attach interrupt to pin, returns slot id
int32_t arduino_irq_attach(uint32_t pin, uint32_t mode) {
  // IMPORTANT: On some Arduino cores (including Due), digitalPinToInterrupt is a macro.
  // Do NOT prefix it with ::
  int irq = digitalPinToInterrupt((uint8_t)pin);

#ifdef NOT_AN_INTERRUPT
  if (irq == NOT_AN_INTERRUPT) {
    return -1;
  }
#else
  if (irq < 0) {
    return -1;
  }
#endif

  // find a free slot
  for (int i = 0; i < ARDUINO_SWIFT_IRQ_SLOTS; i++) {
    if (!gSlots[i].used) {
      gSlots[i].used = 1;
      gSlots[i].irqNumber = (uint8_t)irq;
      gSlots[i].fired = 0;

      ::attachInterrupt(irq, gHandlers[i], (int)mode);
      return (int32_t)i;
    }
  }

  return -1; // no free slot
}

void arduino_irq_detach(int32_t slot) {
  if (slot < 0 || slot >= (int32_t)ARDUINO_SWIFT_IRQ_SLOTS) return;
  if (!gSlots[slot].used) return;

  ::detachInterrupt((int)gSlots[slot].irqNumber);
  gSlots[slot].used = 0;
  gSlots[slot].fired = 0;
  gSlots[slot].irqNumber = 0;
}

uint32_t arduino_irq_consume(int32_t slot) {
  if (slot < 0 || slot >= (int32_t)ARDUINO_SWIFT_IRQ_SLOTS) return 0;
  if (!gSlots[slot].used) return 0;

  // small critical section
  ::noInterrupts();
  uint8_t v = gSlots[slot].fired;
  gSlots[slot].fired = 0;
  ::interrupts();

  return (uint32_t)(v ? 1 : 0);
}

// -------- Serial --------

void arduino_serial_begin(uint32_t baud) {
  ::Serial.begin((unsigned long)baud);
}

void arduino_serial_print_cstr(const char* s) {
  if (!s) return;
  ::Serial.print(s);
}

void arduino_serial_print_i32(int32_t v) {
  ::Serial.print((long)v);
}

void arduino_serial_print_u32(uint32_t v) {
  ::Serial.print((unsigned long)v);
}

void arduino_serial_print_f64(double v) {
  // Arduino Print supports double on SAM (Due). Use a reasonable default precision.
  ::Serial.print(v, 6);
}

} // extern "C"
CPP

# IMPORTANT FIX:
# - declare arduino_swift_runtime_tick as WEAK
# - call it only if present
cat > "$SKETCH/Bridge.cpp" <<'CPP'
#include <Arduino.h>
#include "ArduinoSwiftShim.h"

// Optional runtime tick exported by Swift (ArduinoRuntime).
// If Swift doesn't export it (or it gets stripped), we won't link-break.
extern "C" void arduino_swift_runtime_tick(void) __attribute__((weak));

static bool started = false;

void setup() {
  // Nothing here by default. Swift can call Serial.begin via the shim.
}

void loop() {
  if (!started) {
    started = true;
    // Swift should configure and RETURN.
    arduino_swift_main();
  }

  if (arduino_swift_runtime_tick) {
    arduino_swift_runtime_tick();
  }

  delay(1);
}
CPP

cat > "$SKETCH/SwiftRuntimeSupport.c" <<'C'
// SwiftRuntimeSupport.c
// Minimal C shims so the Embedded Swift runtime can link in Arduino cores.

#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

#ifndef EINVAL
#define EINVAL 22
#endif
#ifndef ENOMEM
#define ENOMEM 12
#endif

int posix_memalign(void **memptr, size_t alignment, size_t size) {
  if (!memptr) return EINVAL;
  if (alignment < sizeof(void*) || (alignment & (alignment - 1)) != 0) return EINVAL;

  uintptr_t raw = (uintptr_t)malloc(size + alignment);
  if (!raw) return ENOMEM;

  uintptr_t aligned = (raw + (alignment - 1)) & ~(uintptr_t)(alignment - 1);
  *memptr = (void*)aligned;
  return 0;
}

void __aeabi_memclr(void *dest, size_t n) { memset(dest, 0, n); }
void __aeabi_memclr4(void *dest, size_t n) { memset(dest, 0, n); }
void __aeabi_memclr8(void *dest, size_t n) { memset(dest, 0, n); }

static uint32_t g_seed = 0x12345678u;
static uint32_t xorshift32(void) {
  uint32_t x = g_seed;
  x ^= x << 13;
  x ^= x >> 17;
  x ^= x << 5;
  g_seed = x;
  return x;
}

void arc4random_buf(void *buf, size_t n) {
  uint8_t *p = (uint8_t *)buf;
  for (size_t i = 0; i < n; i++) {
    if ((i & 3u) == 0u) {
      uint32_t r = xorshift32();
      p[i] = (uint8_t)(r & 0xFFu);
    } else {
      uint32_t r = g_seed;
      p[i] = (uint8_t)((r >> ((i & 3u) * 8u)) & 0xFFu);
    }
  }
}
C

# ----------------------------- Compile Swift into an object file inside the sketch -----------------------------
OBJ="$SKETCH/ArduinoSwiftApp.o"

SWIFT_FLAGS=(
  -target "$SWIFT_TARGET"
  -O
  -wmo
  -parse-as-library

  # Enable Embedded Swift
  -Xfrontend -enable-experimental-feature
  -Xfrontend Embedded

  # Make the produced object match Arduino Due (Cortex-M3, Thumb)
  -Xfrontend -target-cpu
  -Xfrontend "$CPU"

  -Xfrontend -disable-stack-protector

  # Match the Arduino core's compilation model
  -Xcc -mcpu="$CPU"
  -Xcc -mthumb
  -Xcc -ffreestanding
  -Xcc -fno-builtin
  -Xcc -fdata-sections
  -Xcc -ffunction-sections

  # Try to match Arduino's enum model (we also pass to arduino-cli below)
  -Xcc -fno-short-enums
)

ce_title "Compiling Swift"
ce_info "Output: $OBJ"
SWIFT_SRCS=(
  "$ROOT_DIR/swift/"*.swift
)

run_cmd_tee "$LOG_FILE" "$SWIFTC" \
  "${SWIFT_FLAGS[@]}" \
  "${SWIFT_SRCS[@]}" \
  -c -o "$OBJ"

# ----------------------------- Build with Arduino CLI -----------------------------
ce_title "Building with Arduino CLI"
ce_info "FQBN: $FQBN"
run_cmd_bg_tee "$LOG_FILE" "arduino-cli compile..." arduino-cli compile \
  --clean \
  --fqbn "$FQBN" \
  --build-path "$ARD_BUILD" \
  --build-property "compiler.c.extra_flags=-fno-short-enums" \
  --build-property "compiler.cpp.extra_flags=-fno-short-enums" \
  --build-property "compiler.c.elf.extra_flags=$OBJ" \
  "$SKETCH"

ce_ok "compile complete"
ce_ok "Log: $LOG_FILE"
ce_info "Build artifacts: $ARD_BUILD"