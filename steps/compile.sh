#!/usr/bin/env bash
set -euo pipefail

: '
compile.sh
----------
What this step does:
  1) Loads build/env.sh (generated by verify) if present
  2) Selects the Embedded Swift toolchain (prefers build/.swiftc_path from verify)
  3) Copies a REAL Arduino sketch (from ./arduino/) into build/sketch/
  4) Compiles Swift code into build/sketch/ArduinoSwiftApp.o using Embedded Swift
  5) Invokes arduino-cli compile to build and link using the Arduino core/toolchain,
     injecting the Swift object into the final linker command.
'

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CONFIG="$ROOT_DIR/config.json"
BOARDS="$ROOT_DIR/boards.json"

PRINT_SH="$ROOT_DIR/print.sh"
BUILD="$ROOT_DIR/build"
LOG_FILE="$BUILD/compile.log"
: > "$LOG_FILE"

# ----------------------------- UI (shared) -----------------------------
if [[ -f "$PRINT_SH" ]]; then
  # shellcheck disable=SC1090
  source "$PRINT_SH"
else
  ce_title() { echo; echo "=================================================="; echo "$*"; echo "=================================================="; }
  ce_step() { echo; echo "=============================="; echo "==> STEP: $*"; echo "=============================="; }
  ce_info() { echo "INFO  $*"; }
  ce_ok()   { echo "OK    $*"; }
  ce_warn() { echo "WARN  $*" >&2; }
  ce_err()  { echo "ERR   $*" >&2; }
  ce_die()  { ce_err "$*"; exit 1; }
  run_cmd_tee() { local lf="$1"; shift; "$@" 2>&1 | tee -a "$lf"; return ${PIPESTATUS[0]}; }
  run_cmd_bg_tee() { local lf="$1"; local msg="$2"; shift 2; ce_info "$msg"; "$@" 2>&1 | tee -a "$lf"; return ${PIPESTATUS[0]}; }
fi

need() {
  if command -v "$1" >/dev/null 2>&1; then
    ce_ok "Found $1"
  else
    ce_die "Missing dependency: $1"
  fi
}

need arduino-cli
need python3

# Make sure swiftly shims are visible in scripts (macOS/Linux)
export PATH="$HOME/.swiftly/bin:$PATH"

SKETCH="$BUILD/sketch"
ARD_BUILD="$BUILD/arduino_build"
ARD_CACHE="$BUILD/arduino_cache"

ce_info "Preparing build directories..."
rm -rf "$ARD_BUILD" "$SKETCH"
mkdir -p "$BUILD" "$SKETCH" "$ARD_BUILD" "$ARD_CACHE"

# ----------------------------- Load env from verify -----------------------------
ENV_SH="$BUILD/env.sh"
if [[ -f "$ENV_SH" ]]; then
  # shellcheck disable=SC1090
  source "$ENV_SH"
fi

# If verify saved the swiftc path, prefer it.
if [[ -f "$BUILD/.swiftc_path" ]]; then
  SWIFTC="$(cat "$BUILD/.swiftc_path")"
fi

# Allow overriding SWIFTC from the environment if user explicitly sets it.
SWIFTC="${SWIFTC:-swiftc}"

# ----------------------------- Read config/boards -----------------------------
BOARD="$(python3 - <<PY
import json
cfg=json.load(open("$CONFIG","r"))
print(cfg["board"])
PY
)"

FQBN="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"]["fqbn"])
PY
)"

SWIFT_TARGET="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"].get("swift_target","armv7-none-none-eabi"))
PY
)"

CPU="$(python3 - <<PY
import json
boards=json.load(open("$BOARDS","r"))
print(boards["$BOARD"].get("cpu","cortex-m3"))
PY
)"

# ----------------------------- Embedded Swift capability check -----------------------------
supports_embedded_swift() {
  local sc="$1"
  [[ -x "$sc" ]] || return 1

  local target="$SWIFT_TARGET"
  local resdir
  resdir="$("$sc" -print-target-info -target "$target" 2>/dev/null | awk -F'"' '/runtimeResourcePath/ {print $4; exit}')"

  [[ -n "$resdir" && -d "$resdir" && -d "$resdir/embedded" ]]
}

if ! command -v "$SWIFTC" >/dev/null 2>&1 && [[ ! -x "$SWIFTC" ]]; then
  ce_die "swiftc not found: $SWIFTC
Tip: run ./run.sh verify
Or set SWIFTC explicitly:
  SWIFTC=/Library/Developer/Toolchains/<SNAPSHOT>.xctoolchain/usr/bin/swiftc ./run.sh compile"
fi

if command -v "$SWIFTC" >/dev/null 2>&1; then
  SWIFTC="$(command -v "$SWIFTC")"
fi

ce_info "swiftc: $SWIFTC"
SWIFT_VER="$($SWIFTC --version 2>/dev/null | tr '\n' ' ')"
ce_info "swiftc --version: $SWIFT_VER"
echo "swiftc --version: $SWIFT_VER" >> "$LOG_FILE"

if ! supports_embedded_swift "$SWIFTC"; then
  ce_die "This swiftc does NOT support Embedded Swift for target '$SWIFT_TARGET'.
Run: ./run.sh verify
Or set SWIFTC explicitly:
  SWIFTC=/Library/Developer/Toolchains/<SNAPSHOT>.xctoolchain/usr/bin/swiftc ./run.sh compile"
fi

# ----------------------------- Copy REAL sketch sources from ./arduino -----------------------------
ARDUINO_DIR="$ROOT_DIR/arduino"

require_in_arduino_dir() {
  local name="$1"
  local src="$ARDUINO_DIR/$name"
  local dst="$SKETCH/$name"
  [[ -f "$src" ]] || ce_die "Missing required file: $src
Put it in: $ARDUINO_DIR/"
  cp "$src" "$dst"
  ce_ok "Using $name -> $dst"
}

ce_title "Preparing Arduino sketch (from ./arduino)"
[[ -d "$ARDUINO_DIR" ]] || ce_die "Missing directory: $ARDUINO_DIR"

# REQUIRED by Arduino CLI:
# Keep sketch.ino present, but it must NOT define setup()/loop()
require_in_arduino_dir "sketch.ino"

# Required bridge/shims:
require_in_arduino_dir "ArduinoSwiftShim.h"
require_in_arduino_dir "ArduinoSwiftShim.cpp"
require_in_arduino_dir "Bridge.cpp"
require_in_arduino_dir "SwiftRuntimeSupport.c"

# ----------------------------- Compile Swift into an object file inside the sketch -----------------------------
OBJ="$SKETCH/ArduinoSwiftApp.o"

SWIFT_FLAGS=(
  -target "$SWIFT_TARGET"
  -O
  -wmo
  -parse-as-library

  -Xfrontend -enable-experimental-feature
  -Xfrontend Embedded

  -Xfrontend -target-cpu
  -Xfrontend "$CPU"

  -Xfrontend -disable-stack-protector

  -Xcc -mcpu="$CPU"
  -Xcc -mthumb
  -Xcc -ffreestanding
  -Xcc -fno-builtin
  -Xcc -fdata-sections
  -Xcc -ffunction-sections
  -Xcc -fno-short-enums
)

ce_title "Compiling Swift"
ce_info "Output: $OBJ"
ce_info "Running: $SWIFTC ${SWIFT_FLAGS[*]} <swift/*.swift> -c -o $OBJ"

SWIFT_SRCS=()
while IFS= read -r f; do
  [[ -n "$f" ]] && SWIFT_SRCS+=("$f")
done < <(find "$ROOT_DIR/swift" -maxdepth 1 -type f -name "*.swift" -print | sort)

if [[ ${#SWIFT_SRCS[@]} -eq 0 ]]; then
  ce_die "No Swift sources found in: $ROOT_DIR/swift"
fi

run_cmd_tee "$LOG_FILE" "$SWIFTC" \
  "${SWIFT_FLAGS[@]}" \
  "${SWIFT_SRCS[@]}" \
  -c -o "$OBJ"

[[ -f "$OBJ" ]] || ce_die "Swift object was not produced: $OBJ"

# ----------------------------- Build with Arduino CLI -----------------------------
ce_title "Building with Arduino CLI"
ce_info "FQBN: $FQBN"

# IMPORTANT:
# 1) Do NOT put quotes around $OBJ inside the property string; they become literal characters.
# 2) Put the object into linker flags via compiler.c.elf.extra_flags.
# 3) Keep -fno-short-enums on C/C++ compilation to match Swift's fixed enums.
LINK_EXTRA_FLAGS="$OBJ"

run_cmd_bg_tee "$LOG_FILE" "arduino-cli compile..." arduino-cli compile \
  --clean \
  --fqbn "$FQBN" \
  --build-path "$ARD_BUILD" \
  --build-cache-path "$ARD_CACHE" \
  --build-property "compiler.c.extra_flags=-fno-short-enums" \
  --build-property "compiler.cpp.extra_flags=-fno-short-enums" \
  --build-property "compiler.c.elf.extra_flags=$LINK_EXTRA_FLAGS" \
  "$SKETCH"

ce_ok "compile complete"
ce_ok "Log: $LOG_FILE"
ce_info "Build artifacts: $ARD_BUILD"